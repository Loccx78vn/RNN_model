[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cao Xuân Lộc",
    "section": "",
    "text": "Xin chào, mình là Lộc, sinh năm 2003 và là một chàng trai đến từ mảnh đất đầy nắng và gió - Phú Yên, Việt Nam. Mình có bằng cử nhân trường Đại học Kinh Tế - Tài Chính (UEF) và chuyên ngành của mình là Logistics và quản lý chuỗi cung ứng.\nLà người có niềm đam mê mạnh mẽ với R, mình có sở thích viết post về việc phân tích dữ liệu với R để ứng dụng vào các công việc, bài toán thường gặp trong Supply Chain. Ngoài ra, sở thích của mình là nghe sách nói và đi bộ!\nCâu slogan mà mình thích nhất là: “Don’t fear the risk, fear the opportunity lost!” và đó cũng là cách mình sống và làm việc đến bây giờ 💝💝💝.\nHi vọng các bạn sẽ thích bài viết của mình!\n    \n    \n    Go to Next Page\n    \n    \n        \n            Go to Next Page\n            ➔"
  },
  {
    "objectID": "torch.html",
    "href": "torch.html",
    "title": "RNN and LSTM model",
    "section": "",
    "text": "Ở đây ta sẽ học về mô hình machine learning được ứng dụng nhiều nhất trong việc phân tích dữ liệu thời gian là RNN và LSTM."
  },
  {
    "objectID": "torch.html#định-nghĩa",
    "href": "torch.html#định-nghĩa",
    "title": "RNN and LSTM model",
    "section": "1 Định nghĩa:",
    "text": "1 Định nghĩa:\n\n1.1 Mô hình RNN:\nĐiểm chung là cả hai mô hình đều thuộc phân lớp Deep learning - nghĩa là học máy sâu với đặc điểm chung là phân chia dữ liệu thành nhiều lớp và bắt đầu “học” dần qua từng lớp để đưa ra kết quả cuối cùng. Ở hình dưới đây, \\(X_o\\) đại diện cho dữ liệu đầu vào, \\(h_t\\) là output đầu ra của từng step và \\(A\\) là những gì đã “học” được tại step đó và được truyền cho step tiếp theo. Trong tài liệu chuẩn thì họ thường kí hiệu là \\(X_t\\), \\(Y_t\\), \\(h_{t-1}\\).\n\n  \n  \n  \n  \n    Hình 1: Minh họa về sự phân chia dữ liệu thành nhiều lớp\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nKhi nhìn hình thì bạn có thể bối rối chưa hiểu các kí tự và hình ảnh thì bạn có thể tưởng tượng học máy như 1 đứa trẻ và để nó có thể hiểu được câu: “Hôm nay con đi học” thì nó phải học từng chữ cái như: a,b,c,… trước ròi mới ghép thành từ đơn như: “Hôm”,“Nay”,… rồi ghép thành câu trên. Vậy giả sử như hôm nay học được từ “Hôm” thì nó sẽ bắt đầu ghi nhớ từ đã học vào trong \\(A\\). Nếu sau này ta cần học máy hiểu câu “Hôm sau con đi chơi” thì tốc độ học của học máy sẽ nhanh lên vì thay vì nó phải học 5 chữ đơn như thông thường thì nó chỉ cần học 4 chữ còn lại trừ chữ “hôm”. Vậy bạn đã hiểu ý tưởng nền tảng của RNN rồi ha!\nNếu muốn hiểu thêm về RNN, bạn có thể tham khảo link này: Recurrent Neural Network: Từ RNN đến LSTM.\nVà trong RNN có 1 vấn đề lớn là Vanishing Gradient nghĩa là mô hình sẽ không còn “học” thêm được nữa cho dù tăng số epochs. Theo phần chứng minh của anh Tuấn cho thấy RNN sẽ luôn xảy ra vấn đề đó cho dù bạn có xây dựng mô hình tốt như thế nào. Điều này có thể hiểu đơn giản như việc bạn học liên tục dẫn tới quá tải. Do đó, RNN chỉ học các thông tin \\(A\\) từ các step gần nhất và đó là lí do ra đời LSTM - Long short term memory.\n\n\n\n\n\n\nWarning\n\n\n\nLưu ý: Điều này không có nghĩa LSTM luôn tốt hơn RNN vì có những bài toán với đầu vào đơn giản thì mô hình chỉ cần học các step đầu là đã “học” đầy đủ thông tin cần thiết. Mô hình LSTM phổ biến với các bài toán phức tạp như tự động dịch ngôn ngữ, ghi chép lại theo giọng nói…\n\n\n\n\n1.2 Mô hình LSTM:\nCó thể xem mô hình LSTM như biến thể của RNN. Về cấu trúc, LSTM có ba cổng chính giúp nó xử lý và duy trì thông tin qua các bước thời gian:\n\nCổng quên (Forget Gate): Quyết định thông tin nào cần bị quên trong trạng thái ô nhớ.\nCổng nhập (Input Gate): Xác định thông tin nào cần được ghi vào trạng thái ô nhớ.\nCổng xuất (Output Gate): Quyết định thông tin nào sẽ được xuất ra từ trạng thái ô nhớ để ảnh hưởng đến dự đoán tiếp theo."
  },
  {
    "objectID": "torch.html#xây-dựng-mô-hình",
    "href": "torch.html#xây-dựng-mô-hình",
    "title": "RNN and LSTM model",
    "section": "2 Xây dựng mô hình:",
    "text": "2 Xây dựng mô hình:\n\n2.1 Load dữ liệu:\nĐầu tiên ta sẽ load dữ liệu lại như trước. Ở đây, để đơn giản, mình chỉ xây dựng mô hình cho product A thôi.\nGiả sử công ty mình đang kinh doanh 3 loại mặt hàng product A,product B,product C và đây là biểu đồ thể hiện nhu cầu của cả 3 mặt hàng từ tháng 5 tới tháng 10.\n\n\nCode\nlibrary(highcharter)\nsales_data |&gt; \n  select(-Weekday) |&gt; \n  pivot_longer(cols = c(Product_A, Product_B, Product_C),\n               names_to = \"Product\",\n               values_to = \"Sales\") |&gt; \n  hchart(\"line\", hcaes(x = Date, y = Sales, group = Product))\n\n\n\n\n\n\nNếu ta phân tich sâu về nhu cầu của từng mặt hàng theo thứ trong tuần, ta sẽ thấy rằng mặt hàng A, B thì bán chạy vào thứ 4 và thứ 7, còn mặt hàng C thì bán chạy vào thứ 2 và thứ 3.\n\nProduct A:Product B:Product C:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThông thường dữ liệu để train model trong machine learning thường cần trải qua bước normalize data nghĩa là đưa tất cả dữ liệu về chung 1 thước đo và phạm vi. Nguyên do vì điều này giúp nhiều thuật toán học máy dễ dàng hội tụ hơn. Ví dụ, các thuật toán như k-Nearest Neighbors (KNN) và Support Vector Machines (SVM) rất nhạy cảm với khoảng cách giữa các điểm dữ liệu nên nếu dữ liệu không được chuẩn hóa, thuật toán có thể ưu tiên các đặc trưng có phạm vi lớn hơn và bỏ qua các đặc trưng có phạm vi nhỏ hơn, dẫn đến hiệu suất kém. Và công thức phổ biến nhất cho chuẩn hóa là:\n\\[\n\\text{Normalized Value} = \\frac{x - \\min(x)}{\\max(x) - \\min(x)}\n\\]\n\n\nCode\n# Create a data frame with the adjusted sales data\nsales_data &lt;- data.frame(\n  Date = dates,\n  Weekday = weekdays,\n  Product_A = product_a_sales,\n  Product_B = product_b_sales,\n  Product_C = product_c_sales\n)\n\n# Convert the sales data to a time series (ts) object for Product A\nproduct_a_ts &lt;- ts(sales_data$Product_A, start = c(2024, 5), \n                   frequency = 365)\n                   \n\n# Normalzie data:\ntime_series_data&lt;-scale(product_a_ts)\n\nlibrary(highcharter)\nhighchart() %&gt;%\n  hc_add_series(data = as.numeric(time_series_data), type = \"line\", name = \"Sales of Product A\") %&gt;%\n  hc_title(text = \"Normalized Time Series of Product A\") %&gt;%\n  hc_xAxis(title = list(text = \"Date\")) %&gt;%\n  hc_yAxis(title = list(text = \"Normalized Sales\")) %&gt;%\n  hc_tooltip(shared = TRUE) %&gt;%\n  hc_plotOptions(line = list(marker = list(enabled = FALSE)))\n\n\n\n\n\n\n\n\n2.2 Chia dữ liệu:\nVậy để train data, mình sẽ chia bộ dữ liệu thành 3 phần:\n\nTraining data: dùng để huấn luyện và xây dựng mô hình.\nEvaluating data: đánh giá mô hình vừa huấn luyện.\nTesting data: dùng để đánh giá lại nếu muốn mô hình học lại dữ liệu\n\n\n\nCode\nlibrary(keras)\nlibrary(tensorflow)\nlibrary(dplyr)\n\n# Function to create supervised learning format from time series\ncreate_supervised_data &lt;- function(series, n_in = 1, n_out = 1) {\n  series &lt;- as.vector(series)  # Convert time series object to vector\n  data &lt;- data.frame(series)\n  \n  # Use base R lag function for ts objects (lag() from stats package)\n  for (i in 1:n_in) {\n    data &lt;- cbind(data, stats::lag(series, -i))\n  }\n  \n  colnames(data) &lt;- c(paste0('t-', 1:n_in), 't+1')  # Correctly name columns\n  return(data)\n}\n\n# Prepare the data with 12 input lags and 1 output (next time step)\nsupervised_data &lt;- create_supervised_data(time_series_data,\n                                          n_in = 12, \n                                          n_out = 1)\n\n# Remove NA rows created by lag function\nsupervised_data &lt;- na.omit(supervised_data)\n\n# Step 2: Split data into training and test sets\ntrain_size &lt;- round(0.7 * nrow(supervised_data))   # 70% for training\nval_size &lt;- round(0.1 * nrow(supervised_data))     # 10% for validation\ntest_size &lt;- nrow(supervised_data) - train_size - val_size  # 20% for testing\n\ntrain_data &lt;- supervised_data[1:train_size, ]\nval_data &lt;- supervised_data[(train_size + 1):(train_size + val_size), ]\ntest_data &lt;- supervised_data[(train_size + val_size + 1):nrow(supervised_data), ]\n\n# Correct column selection\nx_train &lt;- as.matrix(train_data[, 1:12])  # Input features (12 lags)\ny_train &lt;- as.matrix(train_data[, 't+1'])  # Target output (next time step)\n\nx_val &lt;- as.matrix(val_data[, 1:12])  # Input features for validation\ny_val &lt;- as.matrix(val_data[, 't+1'])  # Actual output for validation\n\nx_test &lt;- as.matrix(test_data[, 1:12])  # Input features for testing\ny_test &lt;- as.matrix(test_data[, 't+1'])  # Actual output for testing\n\n\n## Plot the result:\nlibrary(xts)\nn&lt;-quantile(sales_data$Date, \n            probs = c(0, 0.7, 0.8,1), \n            type = 1)\n\nm1&lt;-sales_data %&gt;% \n  filter(Date &lt;= n[[2]])\nm2&lt;-sales_data %&gt;% \n  filter(Date &lt;= n[[3]] & Date &gt; n[[2]])\nm3&lt;-sales_data %&gt;% \n  filter(Date &lt;= n[[4]] & Date &gt; n[[3]])\n\ndemand_training&lt;-xts(x=m1$Product_A,\n                     order.by=m1$Date)\ndemand_testing&lt;-xts(x=m2$Product_A,\n                     order.by=m2$Date)\ndemand_forecasting&lt;-xts(x=m3$Product_A,\n                     order.by=m3$Date)\n\nlibrary(dygraphs)\nlines&lt;-cbind(demand_training,\n             demand_testing,\n             demand_forecasting)\ndygraph(lines,\n        main = \"Training and testing data\", \n        ylab = \"Quantity order (Unit: Millions)\") %&gt;% \n  dySeries(\"demand_training\", label = \"Training data\") %&gt;%\n  dySeries(\"demand_testing\", label = \"Testing data\") %&gt;%\n  dySeries(\"demand_forecasting\", label = \"Forecasting data\") %&gt;%\n  dyOptions(fillGraph = TRUE, fillAlpha = 0.4) %&gt;% \n  dyRangeSelector(height = 20)\n\n\n\n\n\n\n\n\n2.3 Mô hình RNN:\nSau đó, ta sẽ bắt đầu train model bằng cách tạo thêm 12 cột giá trị là giá trị quá khứ của demand. Bạn sẽ bắt đầu định nghĩa mô hình gồm:\n\nInput: dùng hàm layer_input(shape = input_shape) với input_shape là số lượng predictor.\nLayer: là các hidden layer trong mô hình thêm vào bằng hàm layer_dense(x, units = 64, activation = 'relu') với đối số units thường là bội số của 32 như 32,64,256,…\nOutput: dùng hàm layer_dense(x, units = 1) để định nghĩa là đầu ra chỉ có 1 giá trị.\n\n\n\nCode\n# Step 3: Build a simple transformer-like model\nRNN_model &lt;- function(input_shape) {\n  inputs &lt;- layer_input(shape = input_shape)\n\n  # Transformer Encoder Layer (simplified)\n  x &lt;- inputs\n  x &lt;- layer_dense(x, units = 64, activation = 'relu')  # Dense layer\n  x &lt;- layer_dense(x, units = 32, activation = 'relu')  # Another dense layer\n\n  # Output layer\n  x &lt;- layer_dense(x, units = 1)\n  \n  model &lt;- keras_model(inputs, x)\n  return(model)\n}\n\n# Example input shape (12 time steps input per sample)\ninput_shape &lt;- c(12)\n\nRNN_model &lt;- RNN_model(input_shape)\n\n\nĐối với các mô hình truyền thống như linear regression thì bạn đã quen với thông số \\(R^2\\) để đánh giá mô hình, còn với mô hình Machine learning thì dùng khái niệm loss function - hàm mất mát. Về khái niệm, loss function sẽ đo lường chênh lệch giữa predicted và actual trong bộ training data nên khi càng tăng epochs nghĩa là tăng số lần học lại dữ liệu thì loss function sẽ tính ra giá trị càng thấp. Như mô hình trên thì mình đặt đối số loss = mse nghĩa là sử dụng Mean Squared Error để tối ưu quy trình học của học máy. Công thức như sau:\n\\[\nMSE = \\frac{1}{n} \\sum_{i=1}^{n} (y_{\\text{pred}}(i) - y_{\\text{true}}(i))^2\n\\]\nCòn đối số metrics = c('mae') nghĩa là tiêu chí khác để theo dõi và đánh giá mô hình. Vậy tại sao cần có 2 tham số đánh giá song song như vậy là vì như đã nói, nếu bạn càng tăng epochs thì giá trị loss càng thấp trong khi dùng metrics sẽ đưa ra đánh giá khách quan hơn về mô hình mà không phụ thuộc vào số lần epochs. Công thức như sau:\n\\[\n\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |y_{\\text{pred}}(i) - y_{\\text{true}}(i)|\n\\]\nVậy khi chạy code, R sẽ return output như biểu đồ dưới đây là so sánh tham số của mse và mae giữa training data và evaluating data. Ý tưởng là đánh giá thử mô hình có dự đoán tốt không khi có dữ liệu mới vào.\nTiếp theo, ta sẽ dùng test data để đánh giá mô hình vừa xây dựng. Kết quả có vẻ khá tuyệt vì mô hình gần như theo sát được dữ liệu của test data.\n\n\nCode\n# Step 6: Make predictions\nRNN_forecast &lt;- RNN_model %&gt;% \n  predict(x_test)\n\n\n2/2 - 0s - 85ms/epoch - 43ms/step\n\n\nCode\n# Step 7: Combine predicted and observed\nplot_data &lt;- data.frame(\n  time = c(min(m3$Date)-days(1),m3$Date),  # Time for the test set\n  actual = y_test,  # Actual values from the test set\n  forecast = RNN_forecast  # Forecasted values\n)\n\n# Step 8: Plot using Highcharts\nhighchart() %&gt;%\n  hc_title(text = \"Time Series Forecasting with Highcharts\") %&gt;%\n  hc_xAxis(\n    categories = plot_data$time,\n    title = list(text = \"Time\")\n  ) %&gt;%\n  hc_yAxis(\n    title = list(text = \"Value\"),\n    plotLines = list(list(\n      value = 0,\n      width = 1,\n      color = \"gray\"\n    ))\n  ) %&gt;%\n  hc_add_series(\n    name = \"Actual Data\",\n    data = plot_data$actual,\n    type = \"line\",\n    color = \"#1f77b4\"  # Blue color for actual data\n  ) %&gt;%\n  hc_add_series(\n    name = \"Forecast\",\n    data = plot_data$forecast,\n    type = \"line\",\n    color = \"#ff7f0e\"  # Orange color for forecast data\n  ) %&gt;%\n  hc_tooltip(\n    shared = TRUE,\n    crosshairs = TRUE\n  ) %&gt;%\n  hc_legend(\n    enabled = TRUE\n  )\n\n\n\n\n\n\n\n\n2.4 Mô hình LSTM:\nTiếp theo, ta sẽ xây dựng thử mô hình LSTM. Mô hình LSTM thường bao gồm các lớp sau:\n\nLớp LSTM: Đây là lớp chính, có thể có một hoặc nhiều lớp LSTM chồng lên nhau. Mỗi lớp LSTM có thể trả về toàn bộ chuỗi bằng return_sequences = TRUE hoặc chỉ trả về giá trị cuối cùng bằng return_sequences = FALSE.\nLớp Dense: Sau khi thông tin được xử lý qua các lớp LSTM, nó sẽ được đưa qua các lớp Dense (lớp fully connected) để đưa ra dự đoán cuối cùng.\nLớp Dropout (tùy chọn): Để tránh overfitting, có thể thêm lớp dropout để tắt ngẫu nhiên một số nơ-ron trong quá trình huấn luyện.\n\nVậy giờ ta sẽ so sánh với mô hình RNN trước với mô hình LSTM qua 2 thông số đã chọn mse và mae.\n\n\nCode\n# Extract metrics into a data frame\nresults_df &lt;- data.frame(\n  Model = c(\"RNN\", \"LSTM\"),\n  Metric = c(\"Loss\", \"metric\"),\n  MSE = c(RNN_result[[1]],RNN_result[[2]]),\n  MAE = c(LSTM_result[[1]], LSTM_result[[2]])\n)\n\nlibrary(gt)\n# Create a gt table\nresults_df %&gt;%\n  gt() %&gt;%\n  tab_header(\n    title = \"Model Performance Metrics\",\n    subtitle = \"Comparison of MSE and MAE for RNN and LSTM\"\n  ) %&gt;%\n  fmt_number(\n    columns = vars(MSE, MAE),\n    decimals = 4\n  ) %&gt;%\n  cols_label(\n    Model = \"Model Type\",\n    MSE = \"Mean Squared Error\",\n    MAE = \"Mean Absolute Error\"\n  ) %&gt;%\n  tab_options(\n    table.font.size = 14,\n    heading.title.font.size = 16,\n    heading.subtitle.font.size = 14\n  )\n\n\n\n\n\n\n\n\nModel Performance Metrics\n\n\nComparison of MSE and MAE for RNN and LSTM\n\n\nModel Type\nMetric\nMean Squared Error\nMean Absolute Error\n\n\n\n\nRNN\nLoss\n0.0000\n0.0001\n\n\nLSTM\nmetric\n0.0020\n0.0067\n\n\n\n\n\n\n\nKết quả cho thấy mô hình RNN truyền thống đưa ra kết quả tốt hơn LSTM mặc dù sai số của LSTM đều &lt; 0.03 là không quá tệ nhưng tiêu chí vẫn là mô hình nào hiệu quả nhất.\n\n\nCode\nLSTM_forecast &lt;- LSTM_model %&gt;% \n  predict(x_test)\n\n\n2/2 - 1s - 626ms/epoch - 313ms/step\n\n\nCode\ncompare&lt;-data.frame(Date = c(min(m3$Date)-days(1),m3$Date),\n                    LSTM = round(LSTM_forecast - y_test,3),\n                    RNN = round(RNN_forecast - y_test,3)\n)\n\n# Create the highchart plot\nhighchart() %&gt;%\n  hc_chart(type = \"line\") %&gt;%\n  hc_title(text = \"Residual Comparison: LSTM vs RNN\") %&gt;%\n  hc_xAxis(\n    categories = compare$Date,\n    title = list(text = \"Date\")\n  ) %&gt;%\n  hc_yAxis(\n    title = list(text = \"Residuals\"),\n    plotLines = list(\n      list(value = 0, color = \"gray\", width = 1, dashStyle = \"Dash\")\n    )\n  ) %&gt;%\n  hc_add_series(\n    name = \"LSTM Residuals\",\n    data = compare$LSTM,\n    color = \"#1f77b4\"\n  ) %&gt;%\n  hc_add_series(\n    name = \"RNN Residuals\",\n    data = compare$RNN,\n    color = \"#ff7f0e\"\n  ) %&gt;%\n  hc_tooltip(shared = TRUE) %&gt;%\n  hc_legend(enabled = TRUE)"
  },
  {
    "objectID": "torch.html#kết-luận",
    "href": "torch.html#kết-luận",
    "title": "RNN and LSTM model",
    "section": "3 Kết luận:",
    "text": "3 Kết luận:\nNhư vậy, chúng ta đã được học về thuật toán Genetic và mô hình MILP cũng như cách thực hiện trong Rstudio.\nNếu bạn có câu hỏi hay thắc mắc nào, đừng ngần ngại liên hệ với mình qua Gmail. Bên cạnh đó, nếu bạn muốn xem lại các bài viết trước đây của mình, hãy nhấn vào hai nút dưới đây để truy cập trang Rpubs hoặc mã nguồn trên Github. Rất vui được đồng hành cùng bạn, hẹn gặp lại! 😄😄😄\n\n\n\n    \n    \n    Contact Me\n    \n    \n    \n\n\n    \n        Contact Me\n        \n            Your Email:\n            \n            Please enter a valid email address.\n            Send Email\n        \n        \n            \n                \n                     View Code on GitHub\n                \n            \n        \n        \n            \n                \n                     Visit my RPubs"
  }
]