[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cao Xuân Lộc",
    "section": "",
    "text": "Xin chào, mình là Lộc, sinh năm 2003 và là một chàng trai đến từ mảnh đất đầy nắng và gió - Phú Yên, Việt Nam. Mình có bằng cử nhân trường Đại học Kinh Tế - Tài Chính (UEF) và chuyên ngành của mình là Logistics và quản lý chuỗi cung ứng.\nLà người có niềm đam mê mạnh mẽ với R, mình có sở thích viết post về việc phân tích dữ liệu với R để ứng dụng vào các công việc, bài toán thường gặp trong Supply Chain. Ngoài ra, sở thích của mình là nghe sách nói và đi bộ!\nCâu slogan mà mình thích nhất là: “Don’t fear the risk, fear the opportunity lost!” và đó cũng là cách mình sống và làm việc đến bây giờ 💝💝💝.\nHi vọng các bạn sẽ thích bài viết của mình!\n    \n    \n    Go to Next Page\n    \n    \n        \n            Go to Next Page\n            ➔"
  },
  {
    "objectID": "torch.html",
    "href": "torch.html",
    "title": "RNN and LSTM model",
    "section": "",
    "text": "Ở đây ta sẽ học về mô hình machine learning được ứng dụng nhiều nhất trong việc phân tích dữ liệu thời gian là RNN và LSTM."
  },
  {
    "objectID": "torch.html#mô-hình-rnn",
    "href": "torch.html#mô-hình-rnn",
    "title": "RNN and LSTM model",
    "section": "1 Mô hình RNN:",
    "text": "1 Mô hình RNN:\n\n1.1 Định nghĩa:\nĐiểm chung là cả hai mô hình đều thuộc phân lớp Deep learning - nghĩa là học máy sâu với đặc điểm chung là phân chia dữ liệu thành nhiều lớp và bắt đầu “học” dần qua từng lớp để đưa ra kết quả cuối cùng. Ở hình dưới đây, \\(X_o\\) đại diện cho dữ liệu đầu vào, \\(h_t\\) là output đầu ra của từng step và \\(A\\) là những gì đã “học” được tại step đó và được truyền cho step tiếp theo. Trong tài liệu chuẩn thì họ thường kí hiệu là \\(X_t\\), \\(Y_t\\), \\(h_{t-1}\\).\n\n  \n  \n  \n  \n    Hình 1: Minh họa về sự phân chia dữ liệu thành nhiều lớp\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nKhi nhìn hình thì bạn có thể bối rối chưa hiểu các kí tự và hình ảnh thì bạn có thể tưởng tượng học máy như 1 đứa trẻ và để nó có thể hiểu được câu: “Hôm nay con đi học” thì nó phải học từng chữ cái như: a,b,c,… trước ròi mới ghép thành từ đơn như: “Hôm”,“Nay”,… rồi ghép thành câu trên.\nVậy giả sử như hôm nay học được từ “Hôm” thì nó sẽ bắt đầu ghi nhớ từ đã học vào trong \\(A\\). Nếu sau này ta cần học máy hiểu câu “Hôm sau con đi chơi” thì tốc độ học của học máy sẽ nhanh lên vì thay vì nó phải học 5 chữ đơn như thông thường thì nó chỉ cần học 4 chữ còn lại trừ chữ “hôm”. Vậy bạn đã hiểu ý tưởng nền tảng của RNN rồi ha!\n\n\n1.2 Nguyên lí hoạt động:\nĐầu tiên, RNN sẽ tính toán hidden state là \\(h_t\\) với công thức là:\n\\[\n   \\mathbf{h}_t = \\text{activation}(\\mathbf{W}_\\text{hh} \\mathbf{h}_{t-1} + \\mathbf{W}_\\text{xh} \\mathbf{x}_t + \\mathbf{b}_\\text{h})\n\\]\nSau đó, \\(h_t\\) sẽ được làm input cho các state sau và dựa vào đó để tính output với công thức là:\n\\[\ny_t = W_y \\cdot h_t + b_y\n\\]\nVí dụ: Mình muốn dự đoán hành động trong câu nói “I am reading book” bằng mô hình RNN như sau:\n\nBước 1: Chuyển đổi thành dạng số bằng embedding layer:\n\nMình sẽ gán từng từ đơn sang dạng số như:\n\n“I” -&gt; \\(x_1\\)\n“am” -&gt; \\(x_2\\)\n“reading” -&gt; \\(x_3\\)\n“book” -&gt; \\(x_4\\)\nBước 2: Thêm hidden layer và bắt đầu tính toán:\n\nCho input: “I”\n\\[\n   h_1 = \\tanh(W_x \\cdot x_1 + W_h \\cdot h_0 + b)\n\\]\nCho input: “am”\n\\[\n   h_2 = \\tanh(W_x \\cdot x_2 + W_h \\cdot h_1 + b)\n\\]\nCho input: “reading”\n\\[\n   h_3 = \\tanh(W_x \\cdot x_3 + W_h \\cdot h_2 + b)\n\\]\nCho input: “book”\n\\[\n   h_4 = \\tanh(W_x \\cdot x_4 + W_h \\cdot h_3 + b)\n\\]\n\nBước 3: Tính toán output: Dùng hàm activation softmax để phân lớp theo xác suất.\n\n\\[\n\\hat{y} = \\text{softmax}(W_y \\cdot h_4 + b_y)\n\\]\nNếu muốn hiểu thêm về cách hoạt động RNN, bạn có thể tham khảo link này: Recurrent Neural Network: Từ RNN đến LSTM.\n\n\n1.3 Vấn đề lớn của RNN:\nRNN có 1 vấn đề lớn là Vanishing Gradient nghĩa là mô hình sẽ không còn “học” thêm được nữa cho dù tăng số epochs. Nguyên nhân vì sao như vậy thì bạn có thể tham khảo phần chứng minh của anh Tuấn.\n\n  \n  \n  \n  \n    Hình 2: Vanishing Gradient Problem\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nVấn đề này sẽ làm network khó update weight dẫn tới thời gian học lâu và khó để đạt được output. Bạn có thể hiểu đơn giản như việc bạn học liên tục dẫn tới quá tải và RNN cũng không như vậy. Do đó, RNN chỉ học các thông tin từ state gần và đó là lí do ra đời LSTM - Long short term memory.\n\n\n\n\n\n\nWarning\n\n\n\nLưu ý: Điều này không có nghĩa LSTM luôn tốt hơn RNN vì có những bài toán với đầu vào đơn giản thì mô hình chỉ cần học các step đầu là đã “học” đầy đủ thông tin cần thiết. Mô hình LSTM phổ biến với các bài toán phức tạp như tự động dịch ngôn ngữ, ghi chép lại theo giọng nói…\n\n\n\n\n1.4 Mô hình LSTM:\nCó thể xem mô hình LSTM như biến thể của RNN. Về cấu trúc, LSTM phức tạp hơn RNN:\n\n  \n  \n  \n  \n    Hình 3: So sánh mô hình RNN và LSTM\n  \n  \n  \n  \n    Source: Link to Image\n  \n\nCấu trúc cơ bản gồm:\n\nCổng quên (Forget Gate): có tác dụng quyết định thông tin nào cần bị quên trong trạng thái ô nhớ.\nCổng nhập (Input Gate): Xác định thông tin nào cần được ghi vào trạng thái ô nhớ.\nCổng xuất (Output Gate): Quyết định thông tin nào sẽ được xuất ra từ trạng thái ô nhớ để ảnh hưởng đến dự đoán tiếp theo.\n\nBạn có thể kham khảo thêm bài viết của dominhhai về cách hoạt động của RNN và LSTM để hiểu thêm.\nTiếp theo, ta sẽ bắt đầu xây dựng thử mô hình trong R."
  },
  {
    "objectID": "torch.html#xây-dựng-mô-hình",
    "href": "torch.html#xây-dựng-mô-hình",
    "title": "RNN and LSTM model",
    "section": "2 Xây dựng mô hình:",
    "text": "2 Xây dựng mô hình:\n\n2.1 Load dữ liệu:\nĐầu tiên ta sẽ load dữ liệu lại như trước. Ở đây, để đơn giản, mình chỉ xây dựng mô hình cho product A thôi.\nGiả sử công ty mình đang kinh doanh 3 loại mặt hàng product A,product B,product C và đây là biểu đồ thể hiện nhu cầu của cả 3 mặt hàng từ tháng 5 tới tháng 10.\n\n\nCode\nlibrary(highcharter)\nsales_data |&gt; \n  select(-Weekday) |&gt; \n  pivot_longer(cols = c(Product_A, Product_B, Product_C),\n               names_to = \"Product\",\n               values_to = \"Sales\") |&gt; \n  hchart(\"line\", hcaes(x = Date, y = Sales, group = Product))\n\n\n\n\n\n\nNếu ta phân tich sâu về nhu cầu của từng mặt hàng theo thứ trong tuần, ta sẽ thấy rằng mặt hàng A, B thì bán chạy vào thứ 4 và thứ 7, còn mặt hàng C thì bán chạy vào thứ 2 và thứ 3.\n\nProduct A:Product B:Product C:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThông thường dữ liệu để train model trong machine learning thường cần trải qua bước normalize data nghĩa là đưa tất cả dữ liệu về chung 1 thước đo và phạm vi. Nguyên do vì điều này giúp nhiều thuật toán học máy dễ dàng hội tụ hơn. Ví dụ, các thuật toán như k-Nearest Neighbors (KNN) và Support Vector Machines (SVM) rất nhạy cảm với khoảng cách giữa các điểm dữ liệu nên nếu dữ liệu không được chuẩn hóa, thuật toán có thể ưu tiên các đặc trưng có phạm vi lớn hơn và bỏ qua các đặc trưng có phạm vi nhỏ hơn, dẫn đến hiệu suất kém. Và công thức phổ biến nhất cho chuẩn hóa là:\n\\[\n\\text{Normalized Value} = \\frac{x - \\min(x)}{\\max(x) - \\min(x)}\n\\]\n\n\nCode\n# Create a data frame with the adjusted sales data\nsales_data &lt;- data.frame(\n  Date = dates,\n  Weekday = weekdays,\n  Product_A = product_a_sales,\n  Product_B = product_b_sales,\n  Product_C = product_c_sales\n)\n\n# Convert the sales data to a time series (ts) object for Product A\nproduct_a_ts &lt;- ts(sales_data$Product_A, start = c(2024, 5), \n                   frequency = 365)\n                   \n\n# Normalzie data:\ntime_series_data&lt;-scale(product_a_ts)\n\nlibrary(highcharter)\nhighchart() |&gt;\n  hc_add_series(data = as.numeric(time_series_data), type = \"line\", name = \"Sales of Product A\") |&gt;\n  hc_title(text = \"Normalized Time Series of Product A\") |&gt;\n  hc_xAxis(title = list(text = \"Date\")) |&gt;\n  hc_yAxis(title = list(text = \"Normalized Sales\")) |&gt;\n  hc_tooltip(shared = TRUE) |&gt;\n  hc_plotOptions(line = list(marker = list(enabled = FALSE)))\n\n\n\n\n\n\n\n\n2.2 Chia dữ liệu:\nVậy để train data, mình sẽ chia bộ dữ liệu thành 3 phần:\n\nTraining data: dùng để huấn luyện và xây dựng mô hình.\nEvaluating data: đánh giá mô hình vừa huấn luyện.\nTesting data: dùng để đánh giá lại nếu muốn mô hình học lại dữ liệu\n\n\n\nCode\nsales_data &lt;- data.frame(\n  Date = dates,\n  Weekday = weekdays,\n  Product_A = product_a_sales,\n  Product_B = product_b_sales,\n  Product_C = product_c_sales\n)\n\n# Convert the sales data to a time series (ts) object for Product A\ntime_series_data &lt;- scale(ts(sales_data$Product_A, start = c(2024, 5), \n                   frequency = 365))\n                   \n\ncreate_supervised_data &lt;- function(series, n) {\n  series &lt;- as.vector(series)  # Convert time series object to vector\n  data &lt;- data.frame(series)    # Initialize data frame with the original series\n  \n  # Create lag columns\n  for (i in 1:n) {\n    lagged_column &lt;- lag(series, i)  # Get lagged values\n    data &lt;- cbind(data, lagged_column)  # Add lagged column to the data\n  }\n  \n  # Name the columns properly\n  colnames(data) &lt;- c(paste0('t-', n:1), 't+1')\n  \n  # Remove rows with NA values (those at the start of the series due to lagging)\n  data &lt;- na.omit(data)\n  \n  return(data)\n}\n\n# Prepare the data with 12 input lags and 1 output (next time step)\nsupervised_data &lt;- create_supervised_data(time_series_data,\n                                          n = 50)\n\n# Step 2: Split data into training and test sets\ntrain_size &lt;- round(0.7 * nrow(supervised_data))   # 70% for training\nval_size &lt;- round(0.1 * nrow(supervised_data))     # 10% for validation\ntest_size &lt;- nrow(supervised_data) - train_size - val_size  # 20% for testing\n\ntrain_data &lt;- supervised_data[1:train_size, ]\nval_data &lt;- supervised_data[(train_size + 1):(train_size + val_size), ]\ntest_data &lt;- supervised_data[(train_size + val_size + 1):nrow(supervised_data), ]\n\n# Correct column selection\nx_train &lt;- as.matrix(train_data[, 1:50])  # Input features (12 lags)\ny_train &lt;- as.matrix(train_data[, 't+1'])  # Target output (next time step)\n\nx_val &lt;- as.matrix(val_data[, 1:50])  # Input features for validation\ny_val &lt;- as.matrix(val_data[, 't+1'])  # Actual output for validation\n\nx_test &lt;- as.matrix(test_data[, 1:50])  # Input features for testing\ny_test &lt;- as.matrix(test_data[, 't+1'])  # Actual output for testing\n\n## Plot the result:\nlibrary(xts)\nn&lt;-quantile(sales_data$Date, \n            probs = c(0, 0.7, 0.8,1), \n            type = 1)\n\nm1&lt;-sales_data |&gt; \n  filter(Date &lt;= n[[2]])\nm2&lt;-sales_data |&gt; \n  filter(Date &lt;= n[[3]] & Date &gt; n[[2]])\nm3&lt;-sales_data |&gt; \n  filter(Date &lt;= n[[4]] & Date &gt; n[[3]])\n\ndemand_training&lt;-xts(x=m1$Product_A,\n                     order.by=m1$Date)\ndemand_testing&lt;-xts(x=m2$Product_A,\n                     order.by=m2$Date)\ndemand_forecasting&lt;-xts(x=m3$Product_A,\n                     order.by=m3$Date)\n\nlibrary(dygraphs)\nlines&lt;-cbind(demand_training,\n             demand_testing,\n             demand_forecasting)\ndygraph(lines,\n        main = \"Training and testing data\", \n        ylab = \"Quantity order (Unit: Millions)\") |&gt; \n  dySeries(\"demand_training\", label = \"Training data\") |&gt;\n  dySeries(\"demand_testing\", label = \"Testing data\") |&gt;\n  dySeries(\"demand_forecasting\", label = \"Forecasting data\") |&gt;\n  dyOptions(fillGraph = TRUE, fillAlpha = 0.4) |&gt; \n  dyRangeSelector(height = 20)\n\n\n\n\n\n\n\n\n2.3 Mô hình RNN:\nSau đó, ta sẽ bắt đầu train model bằng cách tạo thêm 12 cột giá trị là giá trị quá khứ của demand. Bạn sẽ bắt đầu định nghĩa mô hình gồm:\n\nInput: dùng hàm layer_input(shape = input_shape) với input_shape là số lượng predictor.\nLayer: là các hidden layer trong mô hình thêm vào bằng hàm layer_dense(x, units = 64, activation = 'relu') với đối số units thường là bội số của 32 như 32,64,256,…\nOutput: dùng hàm layer_dense(x, units = 1) để định nghĩa là đầu ra chỉ có 1 giá trị.\n\nĐối với các mô hình truyền thống như linear regression thì bạn đã quen với thông số \\(R^2\\) để đánh giá mô hình, còn với mô hình Machine learning thì dùng khái niệm loss function - hàm mất mát. Về khái niệm, loss function sẽ đo lường chênh lệch giữa predicted và actual trong bộ training data nên khi càng tăng epochs nghĩa là tăng số lần học lại dữ liệu thì loss function sẽ tính ra giá trị càng thấp. Như mô hình trên thì mình đặt đối số loss = mse nghĩa là sử dụng Mean Squared Error để tối ưu quy trình học của học máy. Công thức như sau:\n\\[\nMSE = \\frac{1}{n} \\sum_{i=1}^{n} (y_{\\text{pred}}(i) - y_{\\text{true}}(i))^2\n\\]\nCòn đối số metrics = c('mae') nghĩa là tiêu chí khác để theo dõi và đánh giá mô hình. Vậy tại sao cần có 2 tham số đánh giá song song như vậy là vì như đã nói, nếu bạn càng tăng epochs thì giá trị loss càng thấp trong khi dùng metrics sẽ đưa ra đánh giá khách quan hơn về mô hình mà không phụ thuộc vào số lần epochs. Công thức như sau:\n\\[\n\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |y_{\\text{pred}}(i) - y_{\\text{true}}(i)|\n\\]\nVậy khi chạy code, R sẽ return output như biểu đồ dưới đây là so sánh tham số của mse và mae giữa training data và evaluating data. Ý tưởng là đánh giá thử mô hình có dự đoán tốt không khi có dữ liệu mới vào.\nTiếp theo, ta sẽ dùng test data để đánh giá mô hình vừa xây dựng. Kết quả có vẻ khá ổn vì mô hình gần như theo sát được dữ liệu của test data.\n\n\nCode\n# Step 6: Make predictions\nRNN_forecast &lt;- RNN_model |&gt; \n  predict(x_test)\n\n\n1/1 - 0s - 291ms/step\n\n\nCode\n# Step 7: Combine predicted and observed\nplot_data &lt;- data.frame(\n  actual = y_test,  # Actual values from the test set\n  forecast = RNN_forecast  # Forecasted values\n)\n\n# Step 8: Plot using Highcharts\nhighchart() |&gt;\n  hc_title(text = \"Time Series Forecasting with Highcharts\") |&gt;\n  hc_xAxis(\n    categories = plot_data$time,\n    title = list(text = \"Time\")\n  ) |&gt;\n  hc_yAxis(\n    title = list(text = \"Value\"),\n    plotLines = list(list(\n      value = 0,\n      width = 1,\n      color = \"gray\"\n    ))\n  ) |&gt;\n  hc_add_series(\n    name = \"Actual Data\",\n    data = plot_data$actual,\n    type = \"line\",\n    color = \"#1f77b4\"  # Blue color for actual data\n  ) |&gt;\n  hc_add_series(\n    name = \"Forecast\",\n    data = plot_data$forecast,\n    type = \"line\",\n    color = \"#ff7f0e\"  # Orange color for forecast data\n  ) |&gt;\n  hc_tooltip(\n    shared = TRUE,\n    crosshairs = TRUE\n  ) |&gt;\n  hc_legend(\n    enabled = TRUE\n  )\n\n\n\n\n\n\n\n\n2.4 Mô hình LSTM:\nTiếp theo, ta sẽ xây dựng thử mô hình LSTM. Mô hình LSTM thường bao gồm các lớp sau:\n\nLớp LSTM: Đây là lớp chính, có thể có một hoặc nhiều lớp LSTM chồng lên nhau. Mỗi lớp LSTM có thể trả về toàn bộ chuỗi bằng return_sequences = TRUE hoặc chỉ trả về giá trị cuối cùng bằng return_sequences = FALSE.\nLớp Dense: Sau khi thông tin được xử lý qua các lớp LSTM, nó sẽ được đưa qua các lớp Dense (lớp fully connected) để đưa ra dự đoán cuối cùng.\nLớp Dropout (tùy chọn): Để tránh overfitting, có thể thêm lớp dropout để tắt ngẫu nhiên một số nơ-ron trong quá trình huấn luyện.\n\nVậy giờ ta sẽ so sánh với mô hình RNN trước với mô hình LSTM qua 2 thông số đã chọn mse và mae.\n\n\nCode\n# Extract metrics into a data frame\nresults_df &lt;- data.frame(\n  Model = c(\"RNN\", \"LSTM\"),\n  MSE = c(RNN_result[[1]],RNN_result[[2]]),\n  MAE = c(LSTM_result[[1]], LSTM_result[[2]])\n)\n\nlibrary(gt)\n# Create a gt table\nresults_df |&gt;\n  gt() |&gt;\n  tab_header(\n    title = \"Model Performance Metrics\",\n    subtitle = \"Comparison of MSE and MAE for RNN and LSTM\"\n  ) |&gt;\n  fmt_number(\n    columns = vars(MSE, MAE),\n    decimals = 6\n  ) |&gt;\n  cols_label(\n    Model = \"Model Type\",\n    MSE = \"Mean Squared Error\",\n    MAE = \"Mean Absolute Error\"\n  ) |&gt;\n  tab_options(\n    table.font.size = 14,\n    heading.title.font.size = 16,\n    heading.subtitle.font.size = 14\n  )\n\n\n\n\n\n\n\n\nModel Performance Metrics\n\n\nComparison of MSE and MAE for RNN and LSTM\n\n\nModel Type\nMean Squared Error\nMean Absolute Error\n\n\n\n\nRNN\n0.622324\n0.790441\n\n\nLSTM\n0.637329\n0.735569\n\n\n\n\n\n\n\nKết quả cho thấy mô hình LSTM đưa ra kết quả tốt hơn RNN với độ sai số thấp hơn nhưng nếu bạn để ý thì thấy trong biểu đồ mình vẫn để % âm để dễ phân biệt giữa việc outstock và high inventory (bởi vì bạn đang dự báo cho nhu cầu của khách hàng). Bạn có thể so sánh thêm 1 bước nữa về tổng chi phí giữa 2 mô hình về outstock và holding cost để có cái nhìn tổng quan nhất.\n\n\nCode\nLSTM_forecast &lt;- LSTM_model |&gt; \n  predict(x_test)\n\n\n1/1 - 0s - 350ms/step\n\n\nCode\ncompare&lt;-data.frame(Date = 1:length(y_test),\n                    LSTM = round((LSTM_forecast - y_test)/y_test,3),\n                    RNN = round((RNN_forecast - y_test)/y_test,3)\n)\n\n# Create the highchart plot with percentage formatting for y-axis\nhighchart() |&gt;\n  hc_chart(type = \"line\") |&gt;\n  hc_title(text = \"Residual Comparison: LSTM vs RNN\") |&gt;\n  hc_xAxis(\n    categories = compare$Date,\n    title = list(text = \"Date\")\n  ) |&gt;\n  hc_yAxis(\n    title = list(text = \"Residuals\"),\n    labels = list(\n      formatter = JS(\"function() { return (this.value).toFixed(0) + '%'; }\")  # Format labels as percentages\n    ),\n    plotLines = list(\n      list(value = 0, color = \"gray\", width = 1, dashStyle = \"Dash\")\n    )\n  ) |&gt;\n  hc_add_series(\n    name = \"LSTM Residuals\",\n    data = compare$LSTM,\n    color = \"#1f77b4\"\n  ) |&gt;\n  hc_add_series(\n    name = \"RNN Residuals\",\n    data = compare$RNN,\n    color = \"#ff7f0e\"\n  ) |&gt;\n  hc_tooltip(shared = TRUE) |&gt;\n  hc_legend(enabled = TRUE)\n\n\n\n\n\n\n\n\n2.5 Xác định cấu trúc mô hình:\nNếu bạn để ý, thực chất code cho mô hình cho như mình đã trình bày thì khá đơn giản và điều khó nhất trong mô hình là xác định số lớp layer trong mô hình. Như bài toán time series forecasting thì mình chỉ cần 2,3 lớp layer đơn giản là đã đạt kết quả tốt với sai số rất thấp (&lt; 0.03), còn với các bài toán phức tạp hơn thì số layer sẽ nhiều hơn.\nVậy quy tắc xác định mô hình là như thế nào ? Câu trả lời là không có quy tắc nào cả và chỉ có các tips mà mình lụm nhặt trên mạng như sau:\n\n2.5.1 Number of layer:\nSố layer nên nằm giữa số input và số output. Như bài thực hành trên thì số layer nên nằm trong khoảng (1,12). Hoặc bạn có thể sử dụng hàm dưới đây để xác định.\n\\[\nN_h = \\frac{N_s}{\\alpha \\cdot (N_i + N_o)}\n\\]\nVới các tham số gồm:\n\n\\(N_h\\) là số lượng hidden neurons.\n\\(N_s\\) là số lượng mẫu trong training data.\n\\(\\alpha\\) là yếu tố tỷ lệ tùy ý (thường từ 2-10).\n\\(N_i\\) là số lượng nơ-ron input\n\\(N_o\\) là số lượng nơ-ron output.\n\nVí dụ như ở mô hình trên thì số hidden layer sẽ khoảng 1-4 layer là ổn (Như trên thì mình dùng 1 layer cho mô hình RNN, 2 layer cho mô hình LSTM)\n\n\n2.5.2 Choose acvtivation function:\nCác hàm activation dùng để tính weighted sum và mỗi layer sẽ cần có 1 hoặc nhiều hàm để tính. Việc lựa chọn hàm ảnh hưởng lớn đến performance của mô hình, thường sẽ được chia thành 3 phần là:\n\nActivation for input layer: thường ko dùng hàm gì cả. Bạn chỉ thực hiện processing dữ liệu để training.\nActivation for Hidden Layers:\n\nThông thường, hàm Tanh thì phù hợp cho dự báo giá trị liên tục từ dữ liệu chuỗi, ReLU giúp cho quá trình training nhanh hơn và không gây ra vanishing problem do không bị chặn, Softmax thường dùng ở output layer cho bài toán classification, Sigmoid thường dùng cho hồi quy logic. Ngoài ra, cách đơn giản hơn là tùy vào loại mô hình bạn đang xây dựng để lựa chọn, ví dụ như tips dưới đây mình tìm hiểu được:\n\n  \n  \n  \n  \n    Hình 4: Tips chọn hàm activation cho hidden layer \n  \n  \n  \n  \n    Source: Link to Image\n  \n\n\nActivation for Output Layers:\n\nĐối với output layer, bạn sẽ lựa chọn hàm dựa trên class của output mà bạn đang hướng đến. Các hàm thông thường sẽ gồm:\n\nLinear: hay còn gọi là “identity” (nhân với 1.0) hoặc “no activation” bởi vì hàm linear tuyến tính không thay đổi weighted sum của input theo bất kỳ cách nào và thay vào đó trả về giá trị trực tiếp. Hàm này thường dùng cho output dạng liên tục.\nLogistic (Sigmoid): áp dụng cho output dạng [0,1] hay còn gọi là binary classification (ví dụ mô hình nhằm đưa ra quyết định có/không trong việc đầu tư vào cổ phiểu này chẳng hạn).\nSoftmax: Hàm này sẽ chuyển đổi một vector thành các giá trị xác suất có tổng bằng 1 (Nó giống như tìm hàm mật độ (PDF) cho một biến). Ứng dụng để dán nhãn cho multiclass thay vì 2 class như hàm sigmoid bên trên. Mỗi nhãn sẽ có 1 giá trị xác suất và dựa vào đó dự đoán khả năng xảy ra của từng class.\n\n\n\n2.5.3 Number of neurons:\nSố lượng nơ-ron trong một lớp quyết định lượng thông tin mà mạng có thể lưu trữ. Nhiều nơ-ron giúp mạng học được các mẫu phức tạp hơn, nhưng cũng làm tăng nguy cơ overfitting (quá khớp) và yêu cầu nhiều tài nguyên tính toán hơn. Bạn có thể bắt đầu với một số lượng nơ-ron tương đối nhỏ, như 128 hoặc 256…"
  },
  {
    "objectID": "torch.html#kết-luận",
    "href": "torch.html#kết-luận",
    "title": "RNN and LSTM model",
    "section": "3 Kết luận:",
    "text": "3 Kết luận:\nNhư vậy, chúng ta đã được học về mô hình RNN và LSTM và cách xây dựng chúng trong R. Tiếp theo, ta sẽ học tiếp về mô hình Transformer\n\n\n\n    \n    \n    Contact Me\n    \n    \n    \n\n\n    \n        Contact Me\n        \n            Your Email:\n            \n            Please enter a valid email address.\n            Send Email\n        \n        \n            \n                \n                     View Code on GitHub\n                \n            \n        \n        \n            \n                \n                     Visit my RPubs"
  }
]